package monolith

import (
	"fmt"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

func TestDescription(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestParts(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
		BytesMessage{bytes: []byte{0xB0}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestValidate(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
		BytesMessage{bytes: []byte{0xB0}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestFixedItems(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A, 0x11}},
		BytesMessage{bytes: []byte{0xB0, 0xB1}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			FixedByteType{Byte: 0x0A},
			FixedByteType{Byte: 0x11},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			FixedByteType{Byte: 0xB0},
			FixedByteType{Byte: 0xB1},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestEnumeratedItems(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x11, 0x12}},
		BytesMessage{bytes: []byte{0x14, 0x13}},
	}

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := NewArgs([]interface{}{0x11, 0x12, 0x14, 0x13})

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestRandomItems(t *testing.T) {
	correct := []int{2, 2}

	rand.Seed(time.Now().UnixNano())

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := NewArgs([]interface{}{0x11, 0x12, 0x14, 0x13})

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	results := instance.Messages()
	fmt.Println(results)

	for index, result := range results {
		if len(result.Bytes()) != correct[index] {
			t.Error("Length of generated bytes does not match correct answer")
		}
	}
}

func TestRandomEnumeratedItems(t *testing.T) {
	correct := []int{2, 2}

	rand.Seed(time.Now().UnixNano())

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	results := instance.Messages()
	fmt.Println(results)

	for index, result := range results {
		if len(result.Bytes()) != correct[index] {
			t.Error("Length of generated bytes does not match correct answer")
		}
	}
}

func TestTimedParts(t *testing.T) {
	correct := []Message{
		TimedMessage{
			bytes:        []byte{0x0A},
			Milliseconds: 0,
		},
		TimedMessage{
			bytes:        []byte{0xB0},
			Milliseconds: 0,
		},
	}

	parts := make([]Monolith, 0)
	part := TimedPart{
		Milliseconds: 0,
		Items:        []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, Monolith(part))
	part = TimedPart{
		Milliseconds: 0,
		Items:        []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, Monolith(part))

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticParts(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
		BytesMessage{bytes: []byte{0x0A}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{SemanticIntProducerByteType{"n", FixedByteType{0x0A}}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{SemanticIntConsumerByteType{"n"}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticDynamicFixedParts(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x04}},
		BytesMessage{bytes: []byte{0x01, 0x01, 0x01, 0x01}},
	}

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x04}},
			},
		},
		&SemanticLengthConsumerDynamicPart{Name: "n", Item: FixedByteType{Byte: 0x01}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticDynamicRandomParts(t *testing.T) {
	correctFirstPart := BytesMessage{bytes: []byte{0x04}}
	correctSecondPartLength := 4

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x04}},
			},
		},
		&SemanticLengthConsumerDynamicPart{Name: "n", Item: RandomByteType{}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}

	if !reflect.DeepEqual(result[0], correctFirstPart) {
		t.Error("Generated bytes do not match correct answer")
	}

	if len(result[1].Bytes()) != correctSecondPartLength {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticSeedDynamicRandomParts(t *testing.T) {
	correctFirstPart := BytesMessage{bytes: []byte{0x04}}
	correctSecondPartLength := 29 // Knowing the correct answer for this requires knowing what the golang PRNG will output for a given seed value.

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x04}},
			},
		},
		&SemanticSeedConsumerDynamicPart{Name: "n", Item: RandomByteType{}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}

	if !reflect.DeepEqual(result[0], correctFirstPart) {
		t.Error("Generated bytes do not match correct answer")
	}

	if len(result[1].Bytes()) != correctSecondPartLength {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticRandomSeedDynamicRandomParts(t *testing.T) {
	rand.Seed(time.Now().UnixNano())

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", RandomByteType{}},
			},
		},
		&SemanticSeedConsumerDynamicPart{Name: "n", Item: RandomByteType{}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticRandomSeedDynamicFixedParts(t *testing.T) {
	rand.Seed(time.Now().UnixNano())

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", RandomByteType{}},
			},
		},
		&SemanticSeedConsumerDynamicPart{Name: "n", Item: SemanticIntConsumerByteType{Name: "n"}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestOptional1(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x01}},
		BytesMessage{bytes: []byte{0x40}},
	}

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x01}},
			},
		},
		&SemanticIntConsumerOptionalPart{
			Name:      "n",
			Condition: EqualsCondition{0x01},
			Item: BytesPart{
				[]ByteType{FixedByteType{0x40}},
			},
		},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestOptional2(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x00}},
	}

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x00}},
			},
		},
		&SemanticIntConsumerOptionalPart{
			Name:      "n",
			Condition: EqualsCondition{0x01},
			Item: BytesPart{
				[]ByteType{FixedByteType{0x40}},
			},
		},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestFixedStringsPart(t *testing.T) {
	correct := []Message{
		StringMessage{String: "Test"},
		StringMessage{String: "Test"},
	}

	parts := make([]Monolith, 0)

	part := StringsPart{
		Items: []StringType{FixedStringType{String: "Test"}},
	}
	parts = append(parts, part)

	part = StringsPart{
		Items: []StringType{FixedStringType{String: "Test"}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	fmt.Println("result 0: " + string(result[0].Bytes()))
	fmt.Println("correct 0: " + string(correct[0].Bytes()))
	fmt.Println("result 1: " + string(result[1].Bytes()))
	fmt.Println("correct 1: " + string(correct[1].Bytes()))

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestVariableStringsPart(t *testing.T) {
	correct := []Message{
		StringMessage{String: "Testserver message."},
		StringMessage{String: "Test"},
	}

	parts := make([]Monolith, 0)

	part := StringsPart{
		Items: []StringType{
			FixedStringType{String: "Test"},
			VariableStringType{EndDelimiter: "."[0]},
			FixedStringType{String: "."},
		},
	}
	parts = append(parts, part)

	part = StringsPart{
		Items: []StringType{FixedStringType{String: "Test"}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewArgs([]interface{}{"server message"}),
	}

	result := instance.Messages()
	fmt.Println(result)

	fmt.Println("result 0: " + string(result[0].Bytes()))
	fmt.Println("correct 0: " + string(correct[0].Bytes()))
	fmt.Println("result 1: " + string(result[1].Bytes()))
	fmt.Println("correct 1: " + string(correct[1].Bytes()))

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestFixedStringsPartReceiver(t *testing.T) {
	correct := []Message{
		StringMessage{String: "Test"},
		StringMessage{String: "Test"},
	}

	senderParts := make([]Monolith, 0)

	part := StringsPart{
		Items: []StringType{FixedStringType{String: "Test"}},
	}
	senderParts = append(senderParts, part)

	part = StringsPart{
		Items: []StringType{FixedStringType{String: "Test"}},
	}
	senderParts = append(senderParts, part)

	senderDescription := Description{senderParts}

	senderInstance := Instance{
		Desc: senderDescription,
		Args: NewEmptyArgs(),
	}

	receiverDescription := Description{senderParts}

	result := senderInstance.Messages()
	fmt.Println(result)

	fmt.Println("result 0: " + string(result[0].Bytes()))
	fmt.Println("correct 0: " + string(correct[0].Bytes()))
	fmt.Println("result 1: " + string(result[1].Bytes()))
	fmt.Println("correct 1: " + string(correct[1].Bytes()))

	buffer := NewEmptyBuffer()
	context := NewEmptyContext()
	for i, v := range result {
		buffer.Push(v.Bytes())
		validated := receiverDescription.Parts[i].Validate(buffer, context)
		switch validated {
		case Invalid:
			t.Error("invalid")
		case Incomplete:
			t.Error("incomplete")
		case Valid:
			return
		}
	}

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestVariableStringsPartReceiver(t *testing.T) {
	correct := []Message{
		StringMessage{String: "Testserver message."},
		StringMessage{String: "Test"},
	}

	senderParts := make([]Monolith, 0)

	senderPart := StringsPart{
		Items: []StringType{
			FixedStringType{String: "Test"},
			VariableStringType{EndDelimiter: "."[0]},
			FixedStringType{String: "."},
		},
	}
	senderParts = append(senderParts, senderPart)

	senderPart = StringsPart{
		Items: []StringType{FixedStringType{String: "Test"}},
	}
	senderParts = append(senderParts, senderPart)

	senderDescription := Description{senderParts}

	senderInstance := Instance{
		Desc: senderDescription,
		Args: NewArgs([]interface{}{"server message"}),
	}

	receiverParts := make([]Monolith, 0)

	receiverPart := StringsPart{
		Items: []StringType{
			FixedStringType{String: "Test"},
			VariableStringType{EndDelimiter: "."[0]},
			FixedStringType{String: "."},
		},
	}
	receiverParts = append(receiverParts, receiverPart)

	receiverPart = StringsPart{
		Items: []StringType{FixedStringType{String: "Test"}},
	}
	receiverParts = append(receiverParts, receiverPart)

	receiverDescription := Description{receiverParts}

	result := senderInstance.Messages()
	fmt.Println(result)

	fmt.Println("result 0: " + string(result[0].Bytes()))
	fmt.Println("correct 0: " + string(correct[0].Bytes()))
	fmt.Println("result 1: " + string(result[1].Bytes()))
	fmt.Println("correct 1: " + string(correct[1].Bytes()))

	buffer := NewEmptyBuffer()
	context := NewEmptyContext()
	for i, v := range result {
		buffer.Push(v.Bytes())
		validated := receiverDescription.Parts[i].Validate(buffer, context)
		switch validated {
		case Invalid:
			t.Error("invalid")
		case Incomplete:
			t.Error("incomplete")
		case Valid:
			return
		}
	}

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}
