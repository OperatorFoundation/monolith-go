package monolith

import (
	"fmt"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

func TestDescription(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestParts(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
		BytesMessage{bytes: []byte{0xB0}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestFixedItems(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A, 0x11}},
		BytesMessage{bytes: []byte{0xB0, 0xB1}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			FixedByteType{Byte: 0x0A},
			FixedByteType{Byte: 0x11},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			FixedByteType{Byte: 0xB0},
			FixedByteType{Byte: 0xB1},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestEnumeratedItems(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x11, 0x12}},
		BytesMessage{bytes: []byte{0x14, 0x13}},
	}

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)
	args = append(args, 0x11, 0x12, 0x14, 0x13)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestRandomItems(t *testing.T) {
	correct := []int{2, 2}

	rand.Seed(time.Now().UnixNano())

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)
	args = append(args, 0x11, 0x12, 0x14, 0x13)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	results := instance.Messages()
	fmt.Println(results)

	for index, result := range results {
		if len(result.Bytes()) != correct[index] {
			t.Error("Length of generated bytes does not match correct answer")
		}
	}
}

func TestRandomEnumeratedItems(t *testing.T) {
	correct := []int{2, 2}

	rand.Seed(time.Now().UnixNano())

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	results := instance.Messages()
	fmt.Println(results)

	for index, result := range results {
		if len(result.Bytes()) != correct[index] {
			t.Error("Length of generated bytes does not match correct answer")
		}
	}
}

func TestTimedParts(t *testing.T) {
	correct := []Message{
		TimedMessage{
			bytes: []byte{0x0A},
			milliseconds: 0,
		},
		TimedMessage{
			bytes: []byte{0xB0},
			milliseconds: 0,
		},
	}

	parts := make([]Monolith, 0)
	part := TimedPart{
		milliseconds: 0,
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, Monolith(part))
	part = TimedPart{
		milliseconds: 0,
		Items: []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, Monolith(part))

	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}
