package monolith

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

func TestDescription(t *testing.T) {
	correct := []byte{0x0A}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestParts(t *testing.T) {
	correct := []byte{0x0A, 0xB0}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Monolith{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestFixedItems(t *testing.T) {
	correct := []byte{0x0A, 0x11, 0xB0, 0xB1}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{
			FixedByteType{Byte: 0x0A},
			FixedByteType{Byte: 0x11},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Monolith{
			FixedByteType{Byte: 0xB0},
			FixedByteType{Byte: 0xB1},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestEnumeratedItems(t *testing.T) {
	correct := []byte{0x11, 0x12, 0x14, 0x13}

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Monolith{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)
	args = append(args, 0x11, 0x12, 0x14, 0x13)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestRandomItems(t *testing.T) {
	correctLen := 4

	rand.Seed(time.Now().UnixNano())

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Monolith{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)
	args = append(args, 0x11, 0x12, 0x14, 0x13)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Bytes()
	fmt.Println(result)

	if len(result) != correctLen {
		t.Error("Length of generated bytes does not match correct answer")
	}
}

func TestRandomEnumeratedItems(t *testing.T) {
	correctLen := 4

	rand.Seed(time.Now().UnixNano())

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Monolith{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Bytes()
	fmt.Println(result)

	if len(result) != correctLen {
		t.Error("Length of generated bytes does not match correct answer")
	}
}

func TestMarshal(t *testing.T) {
	correct := []byte("{\"Desc\":{\"Parts\":[{\"Items\":[{\"Byte\":10}]}]},\"Args\":[]}")

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	desc := Description{parts}

	args := make([]interface{}, 0)

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result, marshalErr := json.Marshal(instance)
	if marshalErr != nil {
		t.Error("Marshal error", marshalErr)
		return
	}

	fmt.Println(string(result))

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
		return
	}
}

func TestUnmarshal(t *testing.T) {
	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []Monolith{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	desc := Description{parts}

	args := make([]interface{}, 0)

	correct := Instance{
		Desc: desc,
		Args: args,
	}

	marshalled := []byte("{\"Desc\":{\"Parts\":[{\"Items\":[{\"Byte\":10}]}]},\"Args\":[]}")

	var instance Instance

	jsonErr := json.Unmarshal(marshalled, &instance)
	if jsonErr != nil {
		t.Error("JSON error", jsonErr)
		return
	}

	fmt.Println(instance)

	if !reflect.DeepEqual(instance, correct) {
		t.Error("Generated bytes do not match correct answer")
		return
	}
}
