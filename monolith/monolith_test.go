package monolith

import (
	"fmt"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

func TestDescription(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestParts(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
		BytesMessage{bytes: []byte{0xB0}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestValidate(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
		BytesMessage{bytes: []byte{0xB0}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}


}

func TestFixedItems(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A, 0x11}},
		BytesMessage{bytes: []byte{0xB0, 0xB1}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			FixedByteType{Byte: 0x0A},
			FixedByteType{Byte: 0x11},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			FixedByteType{Byte: 0xB0},
			FixedByteType{Byte: 0xB1},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestEnumeratedItems(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x11, 0x12}},
		BytesMessage{bytes: []byte{0x14, 0x13}},
	}

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			EnumeratedByteType{set},
			EnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := NewArgs([]interface{}{0x11, 0x12, 0x14, 0x13})

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestRandomItems(t *testing.T) {
	correct := []int{2, 2}

	rand.Seed(time.Now().UnixNano())

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			RandomByteType{},
			RandomByteType{},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	args := NewArgs([]interface{}{0x11, 0x12, 0x14, 0x13})

	instance := Instance{
		Desc: desc,
		Args: args,
	}

	results := instance.Messages()
	fmt.Println(results)

	for index, result := range results {
		if len(result.Bytes()) != correct[index] {
			t.Error("Length of generated bytes does not match correct answer")
		}
	}
}

func TestRandomEnumeratedItems(t *testing.T) {
	correct := []int{2, 2}

	rand.Seed(time.Now().UnixNano())

	set := []byte{0x11, 0x12, 0x13, 0x14}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{
			RandomEnumeratedByteType{set},
			RandomEnumeratedByteType{set},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	results := instance.Messages()
	fmt.Println(results)

	for index, result := range results {
		if len(result.Bytes()) != correct[index] {
			t.Error("Length of generated bytes does not match correct answer")
		}
	}
}

func TestTimedParts(t *testing.T) {
	correct := []Message{
		TimedMessage{
			bytes:        []byte{0x0A},
			Milliseconds: 0,
		},
		TimedMessage{
			bytes:        []byte{0xB0},
			Milliseconds: 0,
		},
	}

	parts := make([]Monolith, 0)
	part := TimedPart{
		Milliseconds: 0,
		Items:        []ByteType{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, Monolith(part))
	part = TimedPart{
		Milliseconds: 0,
		Items:        []ByteType{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, Monolith(part))

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticParts(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x0A}},
		BytesMessage{bytes: []byte{0x0A}},
	}

	parts := make([]Monolith, 0)
	part := BytesPart{
		Items: []ByteType{SemanticIntProducerByteType{"n", FixedByteType{0x0A}}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []ByteType{SemanticIntConsumerByteType{"n"}},
	}
	parts = append(parts, part)

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticDynamicFixedParts(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x04}},
		BytesMessage{bytes: []byte{0x01, 0x01, 0x01, 0x01}},
	}

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x04}},
			},
		},
		&SemanticLengthConsumerDynamicPart{Name: "n", Item:FixedByteType{Byte: 0x01}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticDynamicRandomParts(t *testing.T) {
	correctFirstPart := BytesMessage{bytes: []byte{0x04}}
	correctSecondPartLength := 4

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x04}},
			},
		},
		&SemanticLengthConsumerDynamicPart{Name: "n", Item:RandomByteType{}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}

	if !reflect.DeepEqual(result[0], correctFirstPart) {
		t.Error("Generated bytes do not match correct answer")
	}

	if len(result[1].Bytes()) != correctSecondPartLength {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticSeedDynamicRandomParts(t *testing.T) {
	correctFirstPart := BytesMessage{bytes: []byte{0x04}}
	correctSecondPartLength := 29 // Knowing the correct answer for this requires knowing what the golang PRNG will output for a given seed value.

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x04}},
			},
		},
		&SemanticSeedConsumerDynamicPart{Name: "n", Item:RandomByteType{}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}

	if !reflect.DeepEqual(result[0], correctFirstPart) {
		t.Error("Generated bytes do not match correct answer")
	}

	if len(result[1].Bytes()) != correctSecondPartLength {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticRandomSeedDynamicRandomParts(t *testing.T) {
	rand.Seed(time.Now().UnixNano())

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", RandomByteType{}},
			},
		},
		&SemanticSeedConsumerDynamicPart{Name: "n", Item:RandomByteType{}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestSemanticRandomSeedDynamicFixedParts(t *testing.T) {
	rand.Seed(time.Now().UnixNano())

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", RandomByteType{}},
			},
		},
		&SemanticSeedConsumerDynamicPart{Name: "n", Item:SemanticIntConsumerByteType{Name: "n"}},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if len(result) != 2 {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestOptional1(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x01}},
		BytesMessage{bytes: []byte{0x40}},
	}

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x01}},
			},
		},
		&SemanticIntConsumerOptionalPart{
			Name: "n",
			Condition: EqualsCondition{0x01},
			Item: BytesPart{
				[]ByteType{FixedByteType{0x40}},
			},
		},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestOptional2(t *testing.T) {
	correct := []Message{
		BytesMessage{bytes: []byte{0x00}},
	}

	parts := []Monolith{
		BytesPart{
			Items: []ByteType{
				SemanticIntProducerByteType{"n", FixedByteType{0x00}},
			},
		},
		&SemanticIntConsumerOptionalPart{
			Name: "n",
			Condition: EqualsCondition{0x01},
			Item: BytesPart{
				[]ByteType{FixedByteType{0x40}},
			},
		},
	}

	desc := Description{parts}

	instance := Instance{
		Desc: desc,
		Args: NewEmptyArgs(),
	}

	result := instance.Messages()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}
