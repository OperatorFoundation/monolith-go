package monolith

import (
	"fmt"
	"reflect"
	"testing"
)

func TestDescription(t *testing.T) {
	correct := []byte{0x0A}

	parts := make([]Byteable, 0)
	part := BytesPart{
		Items: []Byteable{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	desc := Description{parts}
	result := desc.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestParts(t *testing.T) {
	correct := []byte{0x0A, 0xB0}

	parts := make([]Byteable, 0)
	part := BytesPart{
		Items: []Byteable{FixedByteType{Byte: 0x0A}},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Byteable{FixedByteType{Byte: 0xB0}},
	}
	parts = append(parts, part)

	desc := Description{parts}
	result := desc.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestItems(t *testing.T) {
	correct := []byte{0x0A, 0x11, 0xB0, 0xB1}

	parts := make([]Byteable, 0)
	part := BytesPart{
		Items: []Byteable{
			FixedByteType{Byte: 0x0A},
			FixedByteType{Byte: 0x11},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Byteable{
			FixedByteType{Byte: 0xB0},
			FixedByteType{Byte: 0xB1},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}
	result := desc.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}

func TestItems(t *testing.T) {
	correct := []byte{0x0A, 0x11, 0xB0, 0xB1}

	parts := make([]Byteable, 0)
	part := BytesPart{
		Items: []Byteable{
			FixedByteType{Byte: 0x0A},
			FixedByteType{Byte: 0x11},
		},
	}
	parts = append(parts, part)
	part = BytesPart{
		Items: []Byteable{
			FixedByteType{Byte: 0xB0},
			FixedByteType{Byte: 0xB1},
		},
	}
	parts = append(parts, part)

	desc := Description{parts}
	result := desc.Bytes()
	fmt.Println(result)

	if !reflect.DeepEqual(result, correct) {
		t.Error("Generated bytes do not match correct answer")
	}
}
